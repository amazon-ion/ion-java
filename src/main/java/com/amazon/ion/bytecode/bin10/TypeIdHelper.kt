// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
package com.amazon.ion.bytecode.bin10

import com.amazon.ion.IonType
import com.amazon.ion.bytecode.ir.OperationKind
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings

internal object TypeIdHelper {

    /**
     * Returns the IonType for a legal Ion 1.0 typeId.
     *
     * The returned value is undefined when attempting to use this function for illegal type IDs.
     */
    @JvmStatic
    fun ionTypeForTypeId(typeId: Int): IonType? {
        return when (typeId shr 4) {
            0x0 -> if (typeId == 0x0F) IonType.NULL else null
            0x1 -> IonType.BOOL
            0x2, 0x3 -> IonType.INT
            0x4 -> IonType.FLOAT
            0x5 -> IonType.DECIMAL
            0x6 -> IonType.TIMESTAMP
            0x7 -> IonType.SYMBOL
            0x8 -> IonType.STRING
            0x9 -> IonType.CLOB
            0xA -> IonType.BLOB
            0xB -> IonType.LIST
            0xC -> IonType.SEXP
            0xD -> IonType.STRUCT
            else -> null
        }
    }

    /**
     * Returns the [OperationKind] for an Ion 1.0 typeId.
     */
    @JvmStatic
    fun operationKindForTypeId(typeId: Int): Int = typeToOperationKindLookup[typeId]

    private val typeToOperationKindLookup = IntArray(256) { initOperationKindForType(it) }

    private fun initOperationKindForType(state: Int): Int {
        return when (state) {
            in 0x00..0x0E -> OperationKind.UNSET
            0x0F -> OperationKind.NULL
            0x10, 0x11, 0x1F -> OperationKind.BOOL
            in 0x20..0x2F -> OperationKind.INT
            in 0x31..0x3F -> OperationKind.INT
            0x40, 0x44, 0x48, 0x4F -> OperationKind.FLOAT
            in 0x50..0x5F -> OperationKind.DECIMAL
            in 0x62..0x6F -> OperationKind.TIMESTAMP
            in 0x70..0x7F -> OperationKind.SYMBOL
            in 0x80..0x8F -> OperationKind.STRING
            in 0x90..0x9F -> OperationKind.CLOB
            in 0xA0..0xAF -> OperationKind.BLOB
            in 0xB0..0xBF -> OperationKind.LIST
            in 0xC0..0xCF -> OperationKind.SEXP
            0xD0, in 0xD2..0xDF -> OperationKind.STRUCT
            0xE0 -> OperationKind.IVM
            in 0xE3..0xEE -> OperationKind.ANNOTATIONS
            // Everything else: 12..1E, 30, D1, EF, F0..FF, illegal timestamp, float, and annotations sizes
            else -> OperationKind.UNSET
        }
    }

    /**
     * A lookup table containing the value length for Ion 1.0 type IDs.
     * A value of -1 indicates that the length follows as a `VarUInt`.
     * A value of -2 indicates that the typeId is not a valid Ion 1.0 typeId.
     *
     * TODO(perf): If there's not a noticeable amount of overhead, we should hide this behind a method instead of
     *     exposing it directly and suppressing the spotbugs error.
     */
    @JvmStatic
    @get:SuppressFBWarnings("MS_EXPOSE_REP", justification = "it is exposed for internal use only as a performance optimization")
    val TYPE_LENGTHS = IntArray(256) { initTypeLength(it) }

    @JvmStatic
    @OptIn(ExperimentalStdlibApi::class)
    private fun initTypeLength(typeId: Int): Int {
        return when (typeId) {
            // The length of all of these is determined entirely by the low-nibble of the typeId.
            0x00, 0x10, 0x20, 0x30, 0x40, 0x50, /* */ 0x70, 0x80, 0x90, 0xA0, 0xB0, 0xC0, 0xD0 /* */ -> 0
            0x01, /* */ 0x21, 0x31, /* */ 0x51, /* */ 0x71, 0x81, 0x91, 0xA1, 0xB1, 0xC1 /* */ /* */ -> 1
            0x02, 0x12, 0x22, 0x32, /* */ 0x52, 0x62, 0x72, 0x82, 0x92, 0xA2, 0xB2, 0xC2, 0xD2 /* */ -> 2
            0x03, 0x13, 0x23, 0x33, /* */ 0x53, 0x63, 0x73, 0x83, 0x93, 0xA3, 0xB3, 0xC3, 0xD3, 0xE3 -> 3
            0x04, 0x14, 0x24, 0x34, 0x44, 0x54, 0x64, 0x74, 0x84, 0x94, 0xA4, 0xB4, 0xC4, 0xD4, 0xE4 -> 4
            0x05, 0x15, 0x25, 0x35, /* */ 0x55, 0x65, 0x75, 0x85, 0x95, 0xA5, 0xB5, 0xC5, 0xD5, 0xE5 -> 5
            0x06, 0x16, 0x26, 0x36, /* */ 0x56, 0x66, 0x76, 0x86, 0x96, 0xA6, 0xB6, 0xC6, 0xD6, 0xE6 -> 6
            0x07, 0x17, 0x27, 0x37, /* */ 0x57, 0x67, 0x77, 0x87, 0x97, 0xA7, 0xB7, 0xC7, 0xD7, 0xE7 -> 7
            0x08, 0x18, 0x28, 0x38, 0x48, 0x58, 0x68, 0x78, 0x88, 0x98, 0xA8, 0xB8, 0xC8, 0xD8, 0xE8 -> 8
            0x09, 0x19, 0x29, 0x39, /* */ 0x59, 0x69, 0x79, 0x89, 0x99, 0xA9, 0xB9, 0xC9, 0xD9, 0xE9 -> 9
            0x0A, 0x1A, 0x2A, 0x3A, /* */ 0x5A, 0x6A, 0x7A, 0x8A, 0x9A, 0xAA, 0xBA, 0xCA, 0xDA, 0xEA -> 10
            0x0B, 0x1B, 0x2B, 0x3B, /* */ 0x5B, 0x6B, 0x7B, 0x8B, 0x9B, 0xAB, 0xBB, 0xCB, 0xDB, 0xEB -> 11
            0x0C, 0x1C, 0x2C, 0x3C, /* */ 0x5C, 0x6C, 0x7C, 0x8C, 0x9C, 0xAC, 0xBC, 0xCC, 0xDC, 0xEC -> 12
            0x0D, 0x1D, 0x2D, 0x3D, /* */ 0x5D, 0x6D, 0x7D, 0x8D, 0x9D, 0xAD, 0xBD, 0xCD, 0xDD, 0xED -> 13
            0x0E, 0x1E, 0x2E, 0x3E, /* */ 0x5E, 0x6E, 0x7E, 0x8E, 0x9E, 0xAE, 0xBE, 0xCE, 0xDE, 0xEE -> -1
            // Bool True
            0x11 -> 0
            // Nulls
            0x0F, 0x1F, 0x2F, 0x3F, 0x4F, 0x5F, 0x6F, 0x7F, 0x8F, 0x9F, 0xAF, 0xBF, 0xCF, 0xDF -> 0
            // IVM
            0xE0 -> 3 // ...3 more than the typeId byte.

            // Reserved and/or illegal typeIds
            0xEF, 0x60, 0x61, 0xD1, 0xE1, 0xE2,
            in 0x41..0x4E, // Illegal float lengths. 0x44 and 0x48 are trapped in the earlier condition.
            in 0xF0..0xFF -> -2
            else -> TODO("This should be unreachable: ${typeId.toHexString()}")
        }
    }
}
