// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
package com.amazon.ion.bytecode.ir

import com.amazon.ion.bytecode.ir.Debugger.invoke
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings
import java.util.function.Consumer

/**
 * Contains static functions for dumping a string representation of the bytecode instructions.
 *
 * E.g.:
 * ```text
 * L0    STRUCT_START L=6
 * L1    . FIELD_NAME_SID $1
 * L2    . LIST_START L=3
 * L3    . . INT_I16 1
 * L4    . . INT_I16 2
 * L5    . END_CONTAINER
 * L6    END_CONTAINER
 * L7    END_OF_INPUT
 * ```
 *
 * This is not performance-optimized at all. Do not use in any happy-path code.
 *
 * This is intended to support testing [BytecodeGenerator]s and to be used as a renderer in a debugger.
 * If we ever choose to expose some sort of debugging utility in the ion-java-cli, it could end up being used there too.
 */
@SuppressFBWarnings(
    value = ["SF_SWITCH_NO_DEFAULT"],
    justification = "Some of the 'when' expressions have 'else' cases with empty bodies, so kotlin doesn't include the default case in the generated bytecode."
)
internal object Debugger {

    @OptIn(ExperimentalStdlibApi::class)
    fun renderSingleInstruction(instruction: Int): String {
        val operationInt = Instructions.toOperation(instruction)
        val instructionInfo = InstructionInfo.entries.singleOrNull { it.operation == operationInt }

        instructionInfo ?: return "UNKNOWN ${instruction.toHexString()}"
        return "${instructionInfo.name} ${instructionInfo.dataType.formatter(Instructions.getData(instruction))}"
    }

    /**
     * Helper function to render bytecode as an `Array<String>` to make it easier to read in the IntelliJ debugger.
     */
    @JvmStatic
    fun renderBytecodeToArray(bytecode: IntArray): Array<String> {
        val sb = StringBuilder()
        renderBytecodeToString(bytecode, sb::append, useIndent = true, useNumbers = false)
        return sb.toString().trim().split("\n").toTypedArray()
    }

    @JvmStatic
    private fun line(n: Int): String {
        return "L$n".padEnd(6, ' ')
    }

    @JvmStatic
    private operator fun Consumer<String>.invoke(value: String) = accept(value)

    /**
     * Writes out some bytecode as a string to the [write] callback function.
     * See [Debugger] documentation and tests for example output.
     */
    @OptIn(ExperimentalStdlibApi::class)
    @JvmStatic
    fun renderBytecodeToString(
        bytecode: IntArray,
        /** The destination for the debug output; default is stdout. */
        write: Consumer<String> = Consumer { print(it) },
        /** Optionally, provide a constant pool to have some supplemental information added for CP_INDEX instructions */
        constantPool: Array<Any?>? = null,
        /** Optionally, provide a symbol table to have some supplemental information added for SID instructions */
        symbolTable: Array<String?>? = null,
        start: Int = 0,
        end: Int = bytecode.size,
        /** Should instructions be indented in accordance the to data model depth? */
        useIndent: Boolean = true,
        /** Should each line begin with a label indicating the instruction number? */
        useNumbers: Boolean = true,
        /** Should it throw an exception for an unrecognized instruction? */
        strict: Boolean = false,
    ) {
        var indent = ""
        var i = start
        while (i < end) {
            if (bytecode[i] == 0) {
                i++
                continue
            }

            if (useNumbers) write(line(i))

            val instruction = bytecode[i++]
            val operationInt = Instructions.toOperation(instruction)
            val instructionInfo = InstructionInfo.entries.singleOrNull { it.operation == operationInt }

            instructionInfo ?: if (strict) {
                throw IllegalStateException("Unknown operation $operationInt at position ${i - 1}.")
            } else {
                write(indent)
                write("UNKNOWN ")
                write(instruction.toHexString())
                write("\n")
                continue
            }

            // Decrease the indent, if necessary.
            if (useIndent) when (instructionInfo) {
                InstructionInfo.END_CONTAINER -> indent = indent.dropLast(2)
                else -> { /* do nothing */ }
            }

            // Write the operation name, and any data carried in the instruction
            write(indent)
            write(instructionInfo.name)

            if (instructionInfo.dataType != InstructionInfo.DataInfo.NO_DATA) {
                write(" ")
                write(instructionInfo.dataType.formatter(Instructions.getData(instruction)).toString())
            }

            // If we have symbol table or constant pool available, add in supplemental information
            if (constantPool != null && instructionInfo.dataType == InstructionInfo.DataInfo.CP_INDEX) {
                val cpIndex = Instructions.getData(instruction)
                if (cpIndex >= constantPool.size) {
                    write("        ERROR: missing constant $cpIndex")
                } else {
                    write("        <${constantPool[cpIndex].toString().take(20)}>")
                }
            }
            if (symbolTable != null && instructionInfo.dataType == InstructionInfo.DataInfo.SID) {
                val sid = Instructions.getData(instruction)
                if (sid == 0) {
                    write("        <$0>")
                } else if (sid >= symbolTable.size) {
                    write("        ERROR: symbol out of bounds $sid")
                } else {
                    write("        <${symbolTable[sid]?.take(20) ?: "$0"}>")
                }
            }

            // Write out the operands
            val operandInfo = instructionInfo.operands
            when (operandInfo.n) {
                1 -> {
                    write("\n")
                    if (useNumbers) write(line(i))
                    val operand = bytecode[i++]
                    write("$indent └─ <${operand.toHexString()}> ${operandInfo.formatter1Int(operand)}".trimEnd())
                }
                2 -> {
                    write("\n")
                    if (useNumbers) write(line(i))
                    val operand1 = bytecode[i++]
                    write("$indent ├─ <${operand1.toHexString()}> ${operandInfo.formatter1Int(operand1)}".trimEnd())
                    write("\n")
                    if (useNumbers) write(line(i))
                    val operand2 = bytecode[i++]
                    write("$indent └─ <${operand2.toHexString()}> ${operandInfo.formatter2Int(operand1, operand2)}".trimEnd())
                }
                else -> { /* do nothing */ }
            }
            write("\n")

            // Adjust indent, if needed.
            if (useIndent) when (instructionInfo) {
                InstructionInfo.DIRECTIVE_SET_SYMBOLS,
                InstructionInfo.DIRECTIVE_ADD_SYMBOLS,
                InstructionInfo.DIRECTIVE_SET_MACROS,
                InstructionInfo.DIRECTIVE_ADD_MACROS,
                InstructionInfo.DIRECTIVE_USE,
                InstructionInfo.DIRECTIVE_MODULE,
                InstructionInfo.DIRECTIVE_IMPORT,
                InstructionInfo.DIRECTIVE_ENCODING,
                InstructionInfo.LIST_START,
                InstructionInfo.SEXP_START,
                InstructionInfo.STRUCT_START -> indent += ". "
                else -> { /* No need to increase the indent */ }
            }

            when (instructionInfo) {
                InstructionInfo.END_OF_INPUT -> break
                else -> continue
            }
        }
    }
}
