// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
package com.amazon.ion.bytecode.bin11.bytearray

import com.amazon.ion.TextToBinaryUtils.hexStringToByteArray
import com.amazon.ion.bytecode.GeneratorTestUtil.assertEqualBytecode
import com.amazon.ion.bytecode.ir.Instructions
import com.amazon.ion.bytecode.util.BytecodeBuffer
import com.amazon.ion.bytecode.util.ConstantPool
import com.amazon.ion.bytecode.util.unsignedToInt
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Test
import org.junit.jupiter.params.ParameterizedTest
import org.junit.jupiter.params.provider.CsvSource
import kotlin.String

class FloatOpcodeHandlerTest {

    @Test
    fun `float0 opcode handler emits correct bytecode`() {
        val inputByteArray: ByteArray = "6A".hexStringToByteArray()
        val buffer = BytecodeBuffer()

        var position = 0
        val opcode = inputByteArray[position++].unsignedToInt()
        position += Float0OpcodeHandler.convertOpcodeToBytecode(
            opcode,
            inputByteArray,
            position,
            buffer,
            ConstantPool(0),
            intArrayOf(),
            intArrayOf(),
            arrayOf()
        )

        val expectedBytecode = intArrayOf(Instructions.I_FLOAT_F32, 0)
        assertEqualBytecode(expectedBytecode, buffer.toArray())
        assertEquals(1, position)
    }

    @ParameterizedTest
    @CsvSource(
        "6B 01 00, 0.000000059604645", // smallest positive subnormal number
        "6B FF 03, 0.000060975552", // largest subnormal number
        "6B 00 04, 0.00006103515625", // smallest positive normal number
        "6B FF 7B, 65504", // largest normal number
        "6B FF 3B, 0.99951172", // largest number less than one
        "6B 00 3C, 1",
        "6B 01 3C, 1.00097656", // smallest number larger than one

        // Same as above, but negative
        "6B 01 80, -0.000000059604645",
        "6B FF 83, -0.000060975552",
        "6B 00 84, -0.00006103515625",
        "6B FF FB, -65504",
        "6B FF BB, -0.99951172",
        "6B 00 BC, -1",
        "6B 01 BC, -1.00097656",

        "6B 00 00, 0",
        "6B 00 80, -0",
        "6B 00 7C, Infinity",
        "6B 00 FC, -Infinity",
        "6B 01 7E, NaN", // quiet NaN
        "6B 01 7C, NaN", // signaling NaN
        "6B 01 FE, NaN", // negative quiet NaN
        "6B 01 FC, NaN", // negative signaling NaN
        "6B 53 7F, NaN", // another quiet NaN
        "6B 53 FF, NaN", // another negative quiet NaN

        "6B 00 C0, -2",
        "6B 55 35, 0.33325195",
        "6B 48 42, 3.140625"
    )
    fun `float16 opcode handler emits correct bytecode`(inputString: String, expectedFloat: Float) {
        val inputByteArray: ByteArray = inputString.hexStringToByteArray()
        val buffer = BytecodeBuffer()

        var position = 0
        val opcode = inputByteArray[position++].unsignedToInt()
        position += Float16OpcodeHandler.convertOpcodeToBytecode(
            opcode,
            inputByteArray,
            position,
            buffer,
            ConstantPool(0),
            intArrayOf(),
            intArrayOf(),
            arrayOf()
        )

        // We cannot use assertEqualBytecode here because Java will parse all the NaNs in the test suite as quiet with
        // all data bits 0, but the actual generated bytecode will have NaN floats with the signaling semantics and data
        // preserved from the input.
        // Instead, test that the buffer is the right length, the instruction is correct, and the stored float has
        // equal value.
        assertEquals(2, buffer.size())
        assertEquals(Instructions.I_FLOAT_F32, buffer.get(0))

        val representedFloat = Float.fromBits(buffer.get(1))
        assertEquals(expectedFloat, representedFloat)

        assertEquals(3, position)
    }

    @ParameterizedTest
    @CsvSource(
        "6C 01 00 00 00, 1.4012984643e-45", // smallest positive subnormal number
        "6C FF FF 7F 00, 1.1754942107e-38", // largest subnormal number
        "6C 00 00 80 00, 1.1754943508e-38", // smallest positive normal number
        "6C FF FF 7F 7F, 3.4028234664e38", // largest normal number
        "6C FF FF 7F 3F, 0.999999940395355225", // largest number less than one
        "6C 00 00 80 3F, 1",
        "6C 01 00 80 3F, 1.00000011920928955", // smallest number larger than one

        // Same as above, but negative
        "6C 01 00 00 80, -1.4012984643e-45",
        "6C FF FF 7F 80, -1.1754942107e-38",
        "6C 00 00 80 80, -1.1754943508e-38",
        "6C FF FF 7F FF, -3.4028234664e38",
        "6C FF FF 7F BF, -0.999999940395355225",
        "6C 00 00 80 BF, -1",
        "6C 01 00 80 BF, -1.00000011920928955",

        "6C 00 00 00 00, 0",
        "6C 00 00 00 80, -0",
        "6C 00 00 80 7F, Infinity",
        "6C 00 00 80 FF, -Infinity",
        "6C 01 00 C0 7F, NaN", // quiet NaN
        "6C 01 00 80 7F, NaN", // signaling NaN
        "6C 01 00 C0 FF, NaN", // negative quiet NaN
        "6C 01 00 80 FF, NaN", // negative signaling NaN

        "6C 00 00 00 C0, -2",
        "6C AB AA AA 3E, 0.333333343267440796",
        "6C DB 0F 49 40, 3.14159274101257324"
    )
    fun `float32 opcode handler emits correct bytecode`(inputString: String, expectedFloat: Float) {
        val inputByteArray: ByteArray = inputString.hexStringToByteArray()
        val buffer = BytecodeBuffer()

        var position = 0
        val opcode = inputByteArray[position++].unsignedToInt()
        position += Float32OpcodeHandler.convertOpcodeToBytecode(
            opcode,
            inputByteArray,
            position,
            buffer,
            ConstantPool(0),
            intArrayOf(),
            intArrayOf(),
            arrayOf()
        )

        assertEquals(2, buffer.size())
        assertEquals(Instructions.I_FLOAT_F32, buffer.get(0))

        val representedFloat = Float.fromBits(buffer.get(1))
        assertEquals(expectedFloat, representedFloat)

        assertEquals(5, position)
    }

    @ParameterizedTest
    @CsvSource(
        "6D 01 00 00 00 00 00 00 00, 4.9406564584124654e-324", // smallest positive subnormal number
        "6D FF FF FF FF FF FF 0F 00, 2.2250738585072009e-308", // largest subnormal number
        "6D 00 00 00 00 00 00 10 00, 2.2250738585072014e-308", // smallest positive normal number
        "6D FF FF FF FF FF FF EF 7F, 1.7976931348623157e308", // largest normal number
        "6D FF FF FF FF FF FF EF 3F, 0.99999999999999988898", // largest number less than one
        "6D 00 00 00 00 00 00 F0 3F, 1",
        "6D 01 00 00 00 00 00 F0 3F, 1.0000000000000002220", // smallest number larger than one
        "6D 02 00 00 00 00 00 F0 3F, 1.0000000000000004441", // the second smallest number greater than 1

        // Same as above, but negative
        "6D 01 00 00 00 00 00 00 80, -4.9406564584124654e-324",
        "6D FF FF FF FF FF FF 0F 80, -2.2250738585072009e-308",
        "6D 00 00 00 00 00 00 10 80, -2.2250738585072014e-308",
        "6D FF FF FF FF FF FF EF FF, -1.7976931348623157e308",
        "6D FF FF FF FF FF FF EF BF, -0.99999999999999988898",
        "6D 00 00 00 00 00 00 F0 BF, -1",
        "6D 01 00 00 00 00 00 F0 BF, -1.0000000000000002220",
        "6D 02 00 00 00 00 00 F0 BF, -1.0000000000000004441",

        "6D 00 00 00 00 00 00 00 00, 0",
        "6D 00 00 00 00 00 00 00 80, -0",
        "6D 00 00 00 00 00 00 F0 7F, Infinity",
        "6D 00 00 00 00 00 00 F0 FF, -Infinity",
        "6D 01 00 00 00 00 00 F8 7F, NaN", // quiet NaN
        "6D 01 00 00 00 00 00 F0 7F, NaN", // signaling NaN
        "6D 01 00 00 00 00 00 F8 FF, NaN", // negative quiet NaN
        "6D 01 00 00 00 00 00 F0 FF, NaN", // negative signaling NaN
        "6D FF FF FF FF FF FF FF 7F, NaN", // another quiet NaN
        "6D FF FF FF FF FF FF FF FF, NaN", // another negative quiet NaN

        "6D 00 00 00 00 00 00 00 C0, -2",
        "6D 55 55 55 55 55 55 D5 3F, 0.33333333333333331483",
        "6D 18 2D 44 54 FB 21 09 40, 3.141592653589793116"
    )
    fun `float64 opcode handler emits correct bytecode`(inputString: String, expectedDouble: Double) {
        val inputByteArray: ByteArray = inputString.hexStringToByteArray()
        val buffer = BytecodeBuffer()

        var position = 0
        val opcode = inputByteArray[position++].unsignedToInt()
        position += DoubleOpcodeHandler.convertOpcodeToBytecode(
            opcode,
            inputByteArray,
            position,
            buffer,
            ConstantPool(0),
            intArrayOf(),
            intArrayOf(),
            arrayOf()
        )

        assertEquals(3, buffer.size())
        assertEquals(Instructions.I_FLOAT_F64, buffer.get(0))

        val representedFloat = Double.fromBits(
            buffer.get(1).toLong().shl(32)
                .or(buffer.get(2).toLong().and(0xFFFF_FFFF))
        )
        assertEquals(expectedDouble, representedFloat)

        assertEquals(9, position)
    }
}
