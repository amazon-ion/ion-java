// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
package com.amazon.ion.bytecode.bin11.bytearray

import com.amazon.ion.TextToBinaryUtils.hexStringToByteArray
import com.amazon.ion.bytecode.GeneratorTestUtil.assertEqualBytecode
import com.amazon.ion.bytecode.ir.Instructions
import com.amazon.ion.bytecode.ir.Instructions.packInstructionData
import com.amazon.ion.bytecode.util.BytecodeBuffer
import com.amazon.ion.bytecode.util.ConstantPool
import com.amazon.ion.bytecode.util.unsignedToInt
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.TestInstance
import org.junit.jupiter.params.ParameterizedTest
import org.junit.jupiter.params.provider.Arguments
import org.junit.jupiter.params.provider.MethodSource
import kotlin.random.Random

@TestInstance(TestInstance.Lifecycle.PER_CLASS)
internal class GenericReferenceOpcodeHandlerTest {

    /**
     * Generates tests for handlers that emit similar *_REF bytecode (instructions packed with a UInt22 reference length
     * and followed by a UInt32 position of the data). Returns a list of [Arguments] objects in the form:
     * - Instance of [GenericReferenceOpcodeHandler] to test
     * - Input [ByteArray]
     * - Expected generated bytecode array as [IntArray]
     * - Expected end position as [Int]
     */
    private fun referenceOpcodeHandlerTestCases(): List<Arguments> {
        val arguments = mutableListOf<Arguments>()

        val instructions = arrayOf(
            Pair(Instructions.I_ANNOTATION_REF, 0x59),
            Pair(Instructions.I_INT_REF, 0xF5),
            Pair(Instructions.I_DECIMAL_REF, 0xF6),
            Pair(Instructions.I_TIMESTAMP_REF, 0xF7),
            Pair(Instructions.I_STRING_REF, 0xF8),
            Pair(Instructions.I_SYMBOL_REF, 0xF9),
            Pair(Instructions.I_BLOB_REF, 0xFE),
            Pair(Instructions.I_CLOB_REF, 0xFF),
        )

        val testTemplates = listOf(
            //     Decimal payload length
            //     |   Expected payload start position
            //     |   |        Expected end position after handling
            //     |   |        |   FlexUInt representation of payload length
            //     |   |        |   |
            "      1,  2,       3, 03",
            "      2,  2,       4, 05",
            "      3,  2,       5, 07",
            "      4,  2,       6, 09",
            "      5,  2,       7, 0B",
            "     14,  2,      16, 1D",
            "     63,  2,      65, 7F",
            "     64,  2,      66, 81",
            "    127,  2,     129, FF",
            "    128,  3,     131, 02 02",
            "  16383,  3,   16386, FE FF",
            "  16384,  4,   16388, 04 00 02",
            "2097151,  4, 2097155, FC FF FF",
            "2097152,  5, 2097157, 08 00 00 02",
            "4194303,  5, 4194308, F8 FF FF 03", // maximum length of a payload
            "      1, 13,      14, 00 18 00 00 00 00 00 00 00 00 00 00", // overlong encoding on the FlexUInt
            "      0,  2,       2, 01", // zero-length payload  TODO: is this legal?
        )

        // This loop maps the above templates into a tests for each opcode. The templates above consist of the decimal
        // value of the FlexUInt length prefix, the expected start position of the payload, the expected end position of
        // the generator after executing the handler, and some bytecode representing the FlexUInt length of the payload.
        //
        // The opcode will be prepended to the bytecode string, and random bytes will be generated to fill the payload.
        //
        // Output Arguments objects are tuples of:
        // (GenericReferenceOpcodeHandler to test, bytecode to test, expected bytecode, expected end position)
        //
        // Example - this string:
        // "0B, 5, 2, 7"
        // will emit the following Arguments objects:
        // <OpcodeHandler for I_INT_REF>    , F5 0B <5 random bytes>, <correct INT_REF bytecode>    , 7
        // <OpcodeHandler for I_DECIMAL_REF>, F6 0B <5 random bytes>, <correct DECIMAL_REF bytecode>, 7
        // ...
        val random = Random(100) // Seed so we get the same values every time
        instructions.forEach { (instruction, opcode) ->
            testTemplates.forEach {
                val (payloadLengthStr, expectedPayloadStartPosStr, expectedEndPositionStr, flexUIntStr) = it.split(',')
                val payloadLength = payloadLengthStr.trim().toInt()
                val expectedPayloadStartPosition = expectedPayloadStartPosStr.trim().toInt()
                val expectedEndPosition = expectedEndPositionStr.trim().toInt()

                val payload = Array(payloadLength) { random.nextBits(8).toByte() }.toByteArray()
                arguments.add(
                    Arguments.of(
                        GenericReferenceOpcodeHandler(instruction),
                        byteArrayOf(
                            opcode.toByte(), // write the opcode
                            *flexUIntStr.trim().hexStringToByteArray(), // then the FlexUInt
                            *payload // then the payload bytes
                        ),
                        intArrayOf(
                            instruction.packInstructionData(payloadLength),
                            expectedPayloadStartPosition
                        ),
                        expectedEndPosition
                    )
                )
            }
        }

        return arguments
    }

    /**
     * Test that variable-length payload opcodes generate the correct *_REF bytecode.
     * Does not validate the actual payload in any way.
     */
    @ParameterizedTest
    @MethodSource("referenceOpcodeHandlerTestCases")
    fun `opcodes with variable-length payloads emit correct bytecode`(
        handler: GenericReferenceOpcodeHandler,
        inputByteArray: ByteArray,
        expectedBytecode: IntArray,
        expectedEndPosition: Int
    ) {
        val buffer = BytecodeBuffer()

        var position = 0
        val opcode = inputByteArray[position++].unsignedToInt()
        position += handler.convertOpcodeToBytecode(
            opcode,
            inputByteArray,
            position,
            buffer,
            ConstantPool(0),
            intArrayOf(),
            intArrayOf(),
            arrayOf()
        )

        assertEqualBytecode(expectedBytecode, buffer.toArray())
        assertEquals(expectedEndPosition, position)
    }
}
