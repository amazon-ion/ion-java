// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
package com.amazon.ion.bytecode

import com.amazon.ion.TextToBinaryUtils.hexStringToByteArray
import com.amazon.ion.bytecode.NumericReader.readDouble
import com.amazon.ion.bytecode.NumericReader.readFloat
import com.amazon.ion.bytecode.NumericReader.readFloat16
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.params.ParameterizedTest
import org.junit.jupiter.params.provider.CsvSource

class NumericReaderTest {

    @ParameterizedTest
    @CsvSource(
        "01 00, 0 01100111 00000000000000000000000, 0.000000059604645", // smallest positive subnormal number
        "FF 03, 0 01110000 11111111100000000000000, 0.000060975552", // largest subnormal number
        "00 04, 0 01110001 00000000000000000000000, 0.00006103515625", // smallest positive normal number
        "FF 7B, 0 10001110 11111111110000000000000, 65504", // largest normal number
        "FF 3B, 0 01111110 11111111110000000000000, 0.99951172", // largest number less than one
        "00 3C, 0 01111111 00000000000000000000000, 1",
        "01 3C, 0 01111111 00000000010000000000000, 1.00097656", // smallest number larger than one

        // Same as above, but negative
        "01 80, 1 01100111 00000000000000000000000, -0.000000059604645",
        "FF 83, 1 01110000 11111111100000000000000, -0.000060975552",
        "00 84, 1 01110001 00000000000000000000000, -0.00006103515625",
        "FF FB, 1 10001110 11111111110000000000000, -65504",
        "FF BB, 1 01111110 11111111110000000000000, -0.99951172",
        "00 BC, 1 01111111 00000000000000000000000, -1",
        "01 BC, 1 01111111 00000000010000000000000, -1.00097656",

        "00 00, 0 00000000 00000000000000000000000, 0",
        "00 80, 1 00000000 00000000000000000000000, -0",
        "00 7C, 0 11111111 00000000000000000000000, Infinity",
        "00 FC, 1 11111111 00000000000000000000000, -Infinity",
        "01 7E, 0 11111111 10000000010000000000000, NaN", // quiet NaN
        "01 7C, 0 11111111 00000000010000000000000, NaN", // signaling NaN
        "01 FE, 1 11111111 10000000010000000000000, NaN", // negative quiet NaN
        "01 FC, 1 11111111 00000000010000000000000, NaN", // negative signaling NaN
        "53 7F, 0 11111111 11010100110000000000000, NaN", // another quiet NaN
        "53 FF, 1 11111111 11010100110000000000000, NaN", // another negative quiet NaN

        "00 C0, 1 10000000 00000000000000000000000, -2",
        "55 35, 0 01111101 01010101010000000000000, 0.33325195",
        "48 42, 0 10000000 10010010000000000000000, 3.140625"
    )
    fun testReadFloat16(input: String, expectedBytes: String, expectedValue: Float) {
        val data = input.hexStringToByteArray()

        val value = data.readFloat16(0)

        val expectedRawBits = expectedBytes.replace(" ", "").toUInt(2).toInt()

        assertEquals(expectedRawBits, value.toRawBits())
        assertEquals(expectedValue, value)
    }

    @ParameterizedTest
    @CsvSource(
        "01 00 00 00, 0 00000000 00000000000000000000001, 1.4012984643e-45", // smallest positive subnormal number
        "FF FF 7F 00, 0 00000000 11111111111111111111111, 1.1754942107e-38", // largest subnormal number
        "00 00 80 00, 0 00000001 00000000000000000000000, 1.1754943508e-38", // smallest positive normal number
        "FF FF 7F 7F, 0 11111110 11111111111111111111111, 3.4028234664e38", // largest normal number
        "FF FF 7F 3F, 0 01111110 11111111111111111111111, 0.999999940395355225", // largest number less than one
        "00 00 80 3F, 0 01111111 00000000000000000000000, 1",
        "01 00 80 3F, 0 01111111 00000000000000000000001, 1.00000011920928955", // smallest number larger than one

        // Same as above, but negative
        "01 00 00 80, 1 00000000 00000000000000000000001, -1.4012984643e-45",
        "FF FF 7F 80, 1 00000000 11111111111111111111111, -1.1754942107e-38",
        "00 00 80 80, 1 00000001 00000000000000000000000, -1.1754943508e-38",
        "FF FF 7F FF, 1 11111110 11111111111111111111111, -3.4028234664e38",
        "FF FF 7F BF, 1 01111110 11111111111111111111111, -0.999999940395355225",
        "00 00 80 BF, 1 01111111 00000000000000000000000, -1",
        "01 00 80 BF, 1 01111111 00000000000000000000001, -1.00000011920928955",

        "00 00 00 00, 0 00000000 00000000000000000000000, 0",
        "00 00 00 80, 1 00000000 00000000000000000000000, -0",
        "00 00 80 7F, 0 11111111 00000000000000000000000, Infinity",
        "00 00 80 FF, 1 11111111 00000000000000000000000, -Infinity",
        "01 00 C0 7F, 0 11111111 10000000000000000000001, NaN", // quiet NaN
        "01 00 80 7F, 0 11111111 00000000000000000000001, NaN", // signaling NaN
        "01 00 C0 FF, 1 11111111 10000000000000000000001, NaN", // negative quiet NaN
        "01 00 80 FF, 1 11111111 00000000000000000000001, NaN", // negative signaling NaN

        "00 00 00 C0, 1 10000000 00000000000000000000000, -2",
        "AB AA AA 3E, 0 01111101 01010101010101010101011, 0.333333343267440796",
        "DB 0F 49 40, 0 10000000 10010010000111111011011, 3.14159274101257324"
    )
    fun testReadFloat32(input: String, expectedBytes: String, expectedValue: Float) {
        val data = input.hexStringToByteArray()

        val value = data.readFloat(0)

        val expectedRawBits = expectedBytes.replace(" ", "").toUInt(2).toInt()

        assertEquals(expectedRawBits, value.toRawBits())
        assertEquals(expectedValue, value)
    }

    @ParameterizedTest
    @CsvSource(
        "01 00 00 00 00 00 00 00, 0 00000000000 0000000000000000000000000000000000000000000000000001, 4.9406564584124654e-324", // smallest positive subnormal number
        "FF FF FF FF FF FF 0F 00, 0 00000000000 1111111111111111111111111111111111111111111111111111, 2.2250738585072009e-308", // largest subnormal number
        "00 00 00 00 00 00 10 00, 0 00000000001 0000000000000000000000000000000000000000000000000000, 2.2250738585072014e-308", // smallest positive normal number
        "FF FF FF FF FF FF EF 7F, 0 11111111110 1111111111111111111111111111111111111111111111111111, 1.7976931348623157e308", // largest normal number
        "FF FF FF FF FF FF EF 3F, 0 01111111110 1111111111111111111111111111111111111111111111111111, 0.99999999999999988898", // largest number less than one
        "00 00 00 00 00 00 F0 3F, 0 01111111111 0000000000000000000000000000000000000000000000000000, 1",
        "01 00 00 00 00 00 F0 3F, 0 01111111111 0000000000000000000000000000000000000000000000000001, 1.0000000000000002220", // smallest number larger than one
        "02 00 00 00 00 00 F0 3F, 0 01111111111 0000000000000000000000000000000000000000000000000010, 1.0000000000000004441", // the second smallest number greater than 1

        // Same as above, but negative
        "01 00 00 00 00 00 00 80, 1 00000000000 0000000000000000000000000000000000000000000000000001, -4.9406564584124654e-324",
        "FF FF FF FF FF FF 0F 80, 1 00000000000 1111111111111111111111111111111111111111111111111111, -2.2250738585072009e-308",
        "00 00 00 00 00 00 10 80, 1 00000000001 0000000000000000000000000000000000000000000000000000, -2.2250738585072014e-308",
        "FF FF FF FF FF FF EF FF, 1 11111111110 1111111111111111111111111111111111111111111111111111, -1.7976931348623157e308",
        "FF FF FF FF FF FF EF BF, 1 01111111110 1111111111111111111111111111111111111111111111111111, -0.99999999999999988898",
        "00 00 00 00 00 00 F0 BF, 1 01111111111 0000000000000000000000000000000000000000000000000000, -1",
        "01 00 00 00 00 00 F0 BF, 1 01111111111 0000000000000000000000000000000000000000000000000001, -1.0000000000000002220",
        "02 00 00 00 00 00 F0 BF, 1 01111111111 0000000000000000000000000000000000000000000000000010, -1.0000000000000004441",

        "00 00 00 00 00 00 00 00, 0 00000000000 0000000000000000000000000000000000000000000000000000, 0",
        "00 00 00 00 00 00 00 80, 1 00000000000 0000000000000000000000000000000000000000000000000000, -0",
        "00 00 00 00 00 00 F0 7F, 0 11111111111 0000000000000000000000000000000000000000000000000000, Infinity",
        "00 00 00 00 00 00 F0 FF, 1 11111111111 0000000000000000000000000000000000000000000000000000, -Infinity",
        "01 00 00 00 00 00 F8 7F, 0 11111111111 1000000000000000000000000000000000000000000000000001, NaN", // quiet NaN
        "01 00 00 00 00 00 F0 7F, 0 11111111111 0000000000000000000000000000000000000000000000000001, NaN", // signaling NaN
        "01 00 00 00 00 00 F8 FF, 1 11111111111 1000000000000000000000000000000000000000000000000001, NaN", // negative quiet NaN
        "01 00 00 00 00 00 F0 FF, 1 11111111111 0000000000000000000000000000000000000000000000000001, NaN", // negative signaling NaN
        "FF FF FF FF FF FF FF 7F, 0 11111111111 1111111111111111111111111111111111111111111111111111, NaN", // another quiet NaN
        "FF FF FF FF FF FF FF FF, 1 11111111111 1111111111111111111111111111111111111111111111111111, NaN", // another negative quiet NaN

        "00 00 00 00 00 00 00 C0, 1 10000000000 0000000000000000000000000000000000000000000000000000, -2",
        "55 55 55 55 55 55 D5 3F, 0 01111111101 0101010101010101010101010101010101010101010101010101, 0.33333333333333331483",
        "18 2D 44 54 FB 21 09 40, 0 10000000000 1001001000011111101101010100010001000010110100011000, 3.141592653589793116"
    )
    fun testReadDouble(input: String, expectedBytes: String, expectedValue: Double) {
        val data = input.hexStringToByteArray()

        val value = data.readDouble(0)

        val expectedRawBits = expectedBytes.replace(" ", "").toULong(2).toLong()

        assertEquals(expectedRawBits, value.toRawBits())
        assertEquals(expectedValue, value)
    }
}
