// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
package com.amazon.ion.impl.bin;

import com.amazon.ion.IonDatagram;
import com.amazon.ion.IonInt;
import com.amazon.ion.IonLoader;
import com.amazon.ion.IonReader;
import com.amazon.ion.IonStruct;
import com.amazon.ion.IonSymbol;
import com.amazon.ion.IonType;
import com.amazon.ion.IonWriter;

import java.io.ByteArrayOutputStream;
import java.io.IOException;

import com.amazon.ion.system.IonBinaryWriterBuilder;
import com.amazon.ion.system.IonSystemBuilder;
import org.junit.Before;
import org.junit.Test;

@SuppressWarnings("deprecation")
public class IonManagedBinaryWriterTest extends IonManagedBinaryWriterTestCase
{
    private ByteArrayOutputStream source = new ByteArrayOutputStream();
    private ByteArrayOutputStream expectedOut = new ByteArrayOutputStream();
    private ByteArrayOutputStream source_32K = new ByteArrayOutputStream();
    private ByteArrayOutputStream expectedOut_32K = new ByteArrayOutputStream();
    private ByteArrayOutputStream source_67K = new ByteArrayOutputStream();
    private ByteArrayOutputStream expectedOut_67K = new ByteArrayOutputStream();
    private ByteArrayOutputStream singleTopLevelValue_13B = new ByteArrayOutputStream();

    /**
     * In test data, the field names are generated by appending a continuously increasing integer to the string "taco", resulting in names like "taco0", "taco1", and so on.
     * These field names are paired with symbol IDs and then stored in then symbol table during the writing process.
     * The actual bytes written into the user buffer are these symbol IDs. The symbol IDs start from $10, representing "taco0", and occupy one byte in the buffer. This single-byte representation continues up to "taco117", which corresponds to symbol ID $127.
     * Beyond "taco117", encoding symbol IDs require two bytes.
     * Therefore, for the first 118 ion structs, each takes 10 bytes, and for ion struct from "taco118" to "taco2988", each occupies 11 bytes.
     * Consequently, the total buffer size is calculated as 118 × 10 + (2988 − 118 + 1) × 11 = 32761 bytes, then we keep writing 2990th ion struct which is 11 bytes, which will overflow the block limit of 32768 bytes.
     * After completing the 2990th ion struct, the flush operation will be executed if auto-flush enabled.
     */
    private int FLUSH_PERIOD = 2990;
    @Before
    public void generateTestData() throws IOException {
        // Writing test data with continuous extending symbol table. After completing writing 3300th value, the local symbol table will stop growing.
        IonWriter defaultWriter = IonBinaryWriterBuilder.standard().build(source);
        int i = 0;
        while (i < 3300) {
            defaultWriter.stepIn(IonType.STRUCT);
            defaultWriter.setFieldName("taco" + i);
            defaultWriter.writeString("burrito");
            defaultWriter.stepOut();
            i++;
        }
        while (i >= 3300 && i < 3400) {
            defaultWriter.stepIn(IonType.STRUCT);
            defaultWriter.setFieldName("taco" + 3);
            defaultWriter.writeString("burrito");
            defaultWriter.stepOut();
            i++;
        }
        defaultWriter.close();
        IonReader reader = system().newReader(source.toByteArray());
        // While writing the 2990th data structure, the cumulative size of the written data will exceed the current block size.
        // If auto-flush enabled, the flush() operation will be executed after completing the 2990th struct. The output should be the same as manually flush after writing the 2990th data.
        int index = 0;

        IonWriter expectedWriter = IonBinaryWriterBuilder.standard().withLocalSymbolTableAppendEnabled().build(expectedOut);
        while (reader.next() != null) {
            expectedWriter.writeValue(reader);
            index++;
            if (index == FLUSH_PERIOD) {
                expectedWriter.flush();
                index = 0;
            }
        }
        expectedWriter.finish();
    }

    @Before
    public void generateTestData32K() throws IOException {
        // Writing test data with continuous extending symbol table. The total data written in user's block is 32K.
        IonWriter defaultWriter = IonBinaryWriterBuilder.standard().build(source_32K);
        int i = 0;
        // The total size of first 2989 ion struct will be 118 x 10 + (2988 - 118 + 1) x 11 = 32761 bytes.
        while (i < 2989) {
            defaultWriter.stepIn(IonType.STRUCT);
            defaultWriter.setFieldName("taco" + i);
            defaultWriter.writeString("burrito");
            defaultWriter.stepOut();
            i++;
        }
        // Keep writing 7 bytes to user's buffer until the total data size in the current block is 32768 bytes.
        defaultWriter.writeString("taco__");
        defaultWriter.close();
        IonReader reader = system().newReader(source_32K.toByteArray());
        // No flush should be expected since the total data size written into user's buffer can fit into one block.
        IonWriter expectedWriter = IonBinaryWriterBuilder.standard().withLocalSymbolTableAppendEnabled().build(expectedOut_32K);
        while (reader.next() != null) {
            expectedWriter.writeValue(reader);
        }
        expectedWriter.close();
    }
    @Before
    public void generateTestData67K() throws IOException {
        // Writing test data with continuous extending symbol table. After completing writing 3200th value, the local symbol table will stop growing.
        IonWriter defaultWriter = IonBinaryWriterBuilder.standard().build(source_67K);
        int i = 0;
        //  The total size of first 3200 ion structs is 118 x 10 + (3199 - 118 + 1) x 11 = 35082 bytes.
        while (i < 3200) {
            defaultWriter.stepIn(IonType.STRUCT);
            defaultWriter.setFieldName("taco" + i);
            defaultWriter.writeString("burrito");
            defaultWriter.stepOut();
            i++;
        }
        // Since we already have symbol token appended in the symbol table for field name "taco3", the size of ion struct after number 3200 to 6399 will be the same, which is 10 bytes.
        // The total size of this part is (6399 - 3200 + 1) x 10 = 31990 bytes. The size of test data would be 35082 + 31990 = 67062 bytes.
        while (i >= 3200 && i < 6400) {
            defaultWriter.stepIn(IonType.STRUCT);
            defaultWriter.setFieldName("taco" + 3);
            defaultWriter.writeString("burrito");
            defaultWriter.stepOut();
            i++;
        }
        defaultWriter.close();
        IonReader reader = system().newReader(source_67K.toByteArray());
        // After writing the 2990th data, the cumulative size of the written data in user's buffer will exceed the current block size.
        // If auto-flush enabled, the flush() operation will be executed after completing the 2990th data. The output should be the same as manually flush after writing the 2990th data.
        int index = 0;
        IonWriter expectedWriter = IonBinaryWriterBuilder.standard().withLocalSymbolTableAppendEnabled().build(expectedOut_67K);
        while (reader.next() != null) {
            expectedWriter.writeValue(reader);
            index++;
            // There is only one flush operation should be expected. After the first flush operation, there will be two blocks allocated in the write buffer which is big enough to fit the rest of data streams.
            if (index == FLUSH_PERIOD) {
                expectedWriter.flush();
            }
        }
        expectedWriter.close();
    }

    @Before
    public void generateSingleTopLevelValue() throws IOException {
        IonWriter defaultWriter = IonBinaryWriterBuilder.standard().build(singleTopLevelValue_13B);
        defaultWriter.writeString("taco_burrito"); // Write a 13-byte IonString.
        defaultWriter.close();
    }

    @Test
    public void testSetStringAnnotations() throws Exception
    {
        writer.setTypeAnnotations("a", "b", "c", "d", "e", "z");
        writer.writeInt(1);
        assertValue("a::b::c::d::e::z::1");
    }

    @Test
    public void testAddStringAnnotation() throws Exception
    {
        writer.addTypeAnnotation("a");
        writer.addTypeAnnotation("b");
        writer.writeInt(1);
        assertValue("a::b::1");
    }

    @Test
    public void testUserSymbol() throws Exception
    {
        writer.writeSymbol("hello");
        assertValue("hello");
    }

    @Test
    public void testSystemSymbol() throws Exception
    {
        writer.writeSymbol("name");
        assertValue("name");
    }

    @Test
    public void testLocalSymbolTableAppend() throws Exception
    {
        writer.writeSymbol("taco");
        writer.flush();
        writer.writeSymbol("burrito");
        writer.finish();

        IonReader reader = system().newReader(writer.getBytes());
        reader.next();
        assertEquals(reader.getSymbolTable().findSymbol("taco"), 15);
        assertEquals(reader.getSymbolTable().findSymbol("burrito"), lstAppendMode.isEnabled() ? -1 : 16);
        reader.next();
        assertEquals(reader.getSymbolTable().findSymbol("taco"), 15);
        assertEquals(reader.getSymbolTable().findSymbol("burrito"), 16);
        assertNull(reader.next());

        IonDatagram dg = system().getLoader().load(writer.getBytes());
        assertEquals(2, dg.size());
        assertEquals("taco", ((IonSymbol) dg.get(0)).stringValue());
        assertEquals("burrito", ((IonSymbol) dg.get(1)).stringValue());
    }

    @Test
    public void testFlushImmediatelyAfterIVM() throws Exception
    {
        writer.flush();
        writer.writeSymbol("burrito");
        writer.finish();
        IonReader reader = system().newReader(writer.getBytes());
        reader.next();
        assertEquals(reader.getSymbolTable().findSymbol("taco"), -1);
        assertEquals(reader.getSymbolTable().findSymbol("burrito"), 15);
        assertNull(reader.next());

        IonDatagram dg = system().getLoader().load(writer.getBytes());
        // Should be IVM SYMTAB burrito
        assertEquals(3, dg.systemSize());
        assertEquals("$ion_symbol_table", ((IonStruct) dg.systemGet(1)).getTypeAnnotations()[0]);
        assertEquals("burrito", ((IonSymbol) dg.systemGet(2)).stringValue());
    }

    @Test
    public void testAutoFlush() throws Exception{
        IonReader reader = system().newReader(source.toByteArray());
        ByteArrayOutputStream actual = new ByteArrayOutputStream();
        IonWriter actualWriter = IonBinaryWriterBuilder.standard().withAutoFlushEnabled(autoFlushMode.isEnabled()).build(actual);
        while (reader.next() != null) {
            actualWriter.writeValue(reader);
        }
        actualWriter.close();
        if (lstAppendMode.isEnabled() && autoFlushMode.isEnabled()) {
            assertArrayEquals(actual.toByteArray(), expectedOut.toByteArray());
        }
        // When auto-flush mode is disabled, the serialized data should be equivalent to the source data without flush operation.
        assertEquivalentDataModel(actual, source);
    }

    @Test
    public void testAutoFlush_32K() throws Exception{
        IonReader reader = system().newReader(source_32K.toByteArray());
        ByteArrayOutputStream actual = new ByteArrayOutputStream();
        IonWriter actualWriter = IonBinaryWriterBuilder.standard().withAutoFlushEnabled(autoFlushMode.isEnabled()).build(actual);
        while (reader.next() != null) {
            actualWriter.writeValue(reader);
        }
        actualWriter.close();
        if (lstAppendMode.isEnabled() && autoFlushMode.isEnabled()) {
            assertArrayEquals(actual.toByteArray(), expectedOut_32K.toByteArray());
        }
        // When auto-flush mode is disabled, the serialized data should be equivalent to the source data without flush operation.
        assertEquivalentDataModel(actual, source_32K);
    }

    @Test
    public void testAutoFlush_67K() throws Exception{
        IonReader reader = system().newReader(source_67K.toByteArray());
        ByteArrayOutputStream actual = new ByteArrayOutputStream();
        IonWriter actualWriter = IonBinaryWriterBuilder.standard().withAutoFlushEnabled(autoFlushMode.isEnabled()).build(actual);
        while (reader.next() != null) {
            actualWriter.writeValue(reader);
        }
        actualWriter.close();
        if (lstAppendMode.isEnabled() && autoFlushMode.isEnabled()) {
            assertArrayEquals(actual.toByteArray(), expectedOut_67K.toByteArray());
        }
        assertEquivalentDataModel(actual, source_67K);
    }

    @Test
    public void testAutoFlush_twiceBlockSize() throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        IonWriter writer = IonBinaryWriterBuilder.standard().build(out);
        writer.writeString("abcdefghijklmnopqrstuvwxyz"); // Write a 27-byte IonString.
        writer.close();
        IonReader reader = system().newReader(out.toByteArray());
        ByteArrayOutputStream actual = new ByteArrayOutputStream();
        // Set the actual writer block size as 10 bytes. The test data is a 27-byte IonString "abcdefghijklmnopqrstuvwxyz".
        IonBinaryWriterBuilder builder = IonBinaryWriterBuilder.standard().withAutoFlushEnabled(autoFlushMode.isEnabled()).withBlockSize(10);
        IonWriter actualWriter = builder.build(actual);
        while (reader.next() != null) {
            actualWriter.writeValue(reader);
        }
        actualWriter.close();
        if (lstAppendMode.isEnabled() && autoFlushMode.isEnabled()) {
            // When auto-flush is enabled, no flush is expected since this is a single top-level value and should continue encoding until this value is completed.
            assertArrayEquals(actual.toByteArray(), out.toByteArray());
        }
        assertEquivalentDataModel(actual, out);
    }

    @Test
    public void testAutoFlush_oneBlockSize() throws IOException {
        IonReader reader = system().newReader(singleTopLevelValue_13B.toByteArray());
        ByteArrayOutputStream actual = new ByteArrayOutputStream();
        // Set the actual writer block size as 13 bytes. The test data is a 13-byte IonString "taco_burrito".
        IonBinaryWriterBuilder builder = IonBinaryWriterBuilder.standard().withAutoFlushEnabled(autoFlushMode.isEnabled()).withBlockSize(13);
        IonWriter actualWriter = builder.build(actual);
        while (reader.next() != null) {
            actualWriter.writeValue(reader);
        }
        actualWriter.close();
        if (lstAppendMode.isEnabled() && autoFlushMode.isEnabled()) {
            // When auto-flush is enabled, no flush is expected since this is a single top-level value and should continue encoding until this value is completed.
            assertArrayEquals(actual.toByteArray(), singleTopLevelValue_13B.toByteArray());
        }
        assertEquivalentDataModel(actual, singleTopLevelValue_13B);
    }

    @Test
    public void testNoNewSymbolsAfterFlush() throws Exception
    {
        writer.writeSymbol("taco");
        writer.flush();
        writer.writeInt(123);
        writer.finish();

        IonDatagram dg = system().getLoader().load(writer.getBytes());
        // Should be IVM SYMTAB taco 123
        assertEquals(4, dg.systemSize());
        assertEquals("$ion_symbol_table", ((IonStruct) dg.systemGet(1)).getTypeAnnotations()[0]);
        assertEquals("taco", ((IonSymbol) dg.systemGet(2)).stringValue());
        assertEquals(123, ((IonInt) dg.systemGet(3)).intValue());
    }

    @Test
    public void testManuallyWriteLSTAppendWithImportsFirst() throws Exception
    {
        writer.writeSymbol("taco");
        writer.addTypeAnnotation("$ion_symbol_table");
        writer.stepIn(IonType.STRUCT);
        writer.setFieldName("imports");
        writer.writeSymbol("$ion_symbol_table");
        writer.setFieldName("symbols");
        writer.stepIn(IonType.LIST);
        writer.writeString("burrito");
        writer.stepOut();
        writer.stepOut();
        writer.writeSymbol("burrito");
        writer.finish();

        IonReader reader = system().newReader(writer.getBytes());
        reader.next();
        assertEquals(reader.getSymbolTable().findSymbol("taco"), 15);
        assertEquals(reader.getSymbolTable().findSymbol("burrito"), lstAppendMode.isEnabled() ? -1 : 16);
        reader.next();
        assertEquals(reader.getSymbolTable().findSymbol("taco"), 15);
        assertEquals(reader.getSymbolTable().findSymbol("burrito"), 16);
        assertNull(reader.next());

        IonDatagram dg = system().getLoader().load(writer.getBytes());
        assertEquals(2, dg.size());
        assertEquals("taco", ((IonSymbol) dg.get(0)).stringValue());
        assertEquals("burrito", ((IonSymbol) dg.get(1)).stringValue());
    }

    @Test
    public void testManuallyWriteLSTAppendWithSymbolsFirst() throws Exception
    {
        writer.writeSymbol("taco");
        writer.addTypeAnnotation("$ion_symbol_table");
        writer.stepIn(IonType.STRUCT);
        writer.setFieldName("symbols");
        writer.stepIn(IonType.LIST);
        writer.writeString("burrito");
        writer.stepOut();
        writer.setFieldName("imports");
        writer.writeSymbol("$ion_symbol_table");
        writer.stepOut();
        writer.writeSymbol("burrito");
        writer.finish();

        IonReader reader = system().newReader(writer.getBytes());
        reader.next();
        assertEquals(reader.getSymbolTable().findSymbol("taco"), 15);
        assertEquals(reader.getSymbolTable().findSymbol("burrito"), lstAppendMode.isEnabled() ? -1 : 16);
        reader.next();
        assertEquals(reader.getSymbolTable().findSymbol("taco"), 15);
        assertEquals(reader.getSymbolTable().findSymbol("burrito"), 16);
        assertNull(reader.next());

        IonDatagram dg = system().getLoader().load(writer.getBytes());
        assertEquals(2, dg.size());
        assertEquals("taco", ((IonSymbol) dg.get(0)).stringValue());
        assertEquals("burrito", ((IonSymbol) dg.get(1)).stringValue());
    }

    @Test
    public void testUserFieldNames() throws Exception
    {
        writer.stepIn(IonType.STRUCT);
        {
            writer.setFieldName("a");
            writer.writeInt(1);

            writer.setFieldName("b");
            writer.writeInt(2);

            writer.setFieldName("c");
            writer.writeInt(3);

            writer.setFieldName("d");
            writer.writeInt(4);

            writer.setFieldName("e");
            writer.writeInt(5);
        }
        writer.stepOut();
        assertValue("{a:1, b:2, c:3, d:4, e:5}");
    }

    @Test
    public void testSymbolTableExport() throws Exception {
        writer.stepIn(IonType.STRUCT);
        {
            writer.setFieldName("a");
            writer.writeInt(1);

            writer.setFieldName("d");
            writer.writeInt(4);
        }
        writer.stepOut();
        assertValue("{a:1, d:4}");

        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        IonWriter symbolTableWriter = system().newBinaryWriter(bos);
        try {
            writer.getSymbolTable().writeTo(symbolTableWriter);
        } finally {
            symbolTableWriter.close();
        }
        // SymbolTable expected = system().newSharedSymbolTable("version", )
        bos.toByteArray();

    }

    @Test
    public void testNestedEmptyContainer() throws Exception
    {
        writer.stepIn(IonType.STRUCT);
        writer.setFieldName("bar");
        writer.stepIn(IonType.LIST);
        writer.stepOut();
        writer.stepOut();
        assertValue("{bar: []}");
    }

    @Test
    public void testNestedEmptyAnnotatedContainer() throws Exception
    {
        writer.stepIn(IonType.STRUCT);
        writer.setFieldName("bar");
        writer.addTypeAnnotation("foo");
        writer.stepIn(IonType.LIST);
        writer.stepOut();
        writer.stepOut();
        assertValue("{bar: foo::[]}");
    }

    /**
     * Asserts equivalence of ion data model between two provided data streams.
     * @param actual represents the serialized data streams when auto-flush is enabled.
     * @param expected represents the expected data streams.
     */
    private void assertEquivalentDataModel(ByteArrayOutputStream actual, ByteArrayOutputStream expected) {
        IonLoader loader = IonSystemBuilder.standard().build().newLoader();
        IonDatagram actualDatagram = loader.load(actual.toByteArray());
        IonDatagram expectedDatagram = loader.load(expected.toByteArray());
        assertEquals(expectedDatagram, actualDatagram);
    }
}
